# Dummy-Robot: Super Compact Smart Robotic Arm
> **My super compact robotic arm project.**
>
> Video Introduction: [【Homemade】I Made a Steel Iron Man Robotic Arm!【Hardcore】](https://www.bilibili.com/video/BV12341117rG)
>
> Video: [I made a DUMMY ROBOTIC ARM from scratch! - YouTube](https://www.youtube.com/watch?v=F29vrvUwqS4)

![](5.Docs/1.Images/dummy1.jpg)

![](5.Docs/1.Images/case.png)

### Documentation (Updated on 22-2-9)

- Добавлены исходные файлы дизайна 3D-моделей.
- Добавлены файлы аппаратного дизайна захвата и печатной платы светодиодного кольца.
- Добавлены файлы печатной платы для беспроводного контроллера пространственного позиционирования.
- Добавлены программное и аппаратное обеспечение для беспроводного устройства обучения Peak (в виде подмодуля).
- Добавлены файлы аппаратного дизайна REF.
- Добавлено настольное приложение DummyStudio.
- Добавлен исходный код прошивки для основного контроллера Dummy (см. инструкции ниже).
- Добавлен проект аппаратной части для шагового двигателя на 42 шага.
- Добавлен проект аппаратной части для шагового двигателя на 20 шагов.
- Добавлен исходный код прошивки для шаговых двигателей на 42/20 шагов.
- Добавлен инструмент командной строки "reftool" (на основе фреймворка odrivetool).
- Добавлены файлы модели для портативного переносного кейса.

> Это полное решение для оригинального роботизированного манипулятора, показанного в видео. Стоимость и сложность этого варианта довольно высоки, поэтому я рекомендую дождаться выхода **молодежной версии Dummy**, если вы хотите его воспроизвести. Молодежная версия будет включать следующие улучшения:

1. Общая конструкция будет переработана с использованием 3D-печати в качестве производственного решения (в оригинальной версии используется алюминиевое ЧПУ), что значительно снизит затраты на производство.
2. Будет использоваться мой собственный компактный циклоидальный редуктор вместо оригинального гармонического привода, что значительно снизит стоимость компонентов.
3. Всё программное и аппаратное обеспечение будут совместимы и сохранят ту же функциональность, что и в оригинальной версии.
4. Будет включено приложение для ПК и мобильное приложение (с руководством по первоначальной настройке для пользователей), разработанные мною.
5. Метод подключения оригинального привода двигателя будет улучшен. В оригинальной версии для подключения питания использовалась пайка, что неудобно для установки и демонтажа. В молодежной версии будет использоваться 4-контактный разъем (питание + шина CAN).
6. Общая стоимость будет стремиться оставаться ниже 2000 единиц.
7. **И самое главное, будет полноценное видео-руководство!**

## О конструктивной части

Оригинальная конструкция, показанная в видео, использует шаговые двигатели и гармонический редуктор. Последний является довольно дорогим компонентом (я купил б/у примерно за 600 единиц), поэтому, чтобы сделать проект более доступным для всех, я позже добавлю бюджетное решение с использованием самодельного циклоидального редуктора и 3D-печати.

> Циклоидальный редуктор уже разработан и в настоящее время проходит тестирование. Ожидается, что он будет изготовлен с помощью резки из поликарбоната (или акрила) в сочетании с 3D-печатью, что приведет к небольшому снижению точности, но сохранит всю функциональность. Ожидается, что стоимость всего оборудования будет удерживаться в пределах 2000 единиц.

Разработанный циклоидальный редуктор можно найти в моем другом репозитории: [peng-zhihui/CycloidAcuratorNano](https://github.com/peng-zhihui/CycloidAcuratorNano).

![](5.Docs/1.Images/cycliod-nano.jpg)

## О модулях схемы

Для реализации основной функции управления движением роботизированного манипулятора схема состоит из четырёх основных плат:

- Основная плата REF
- Плата основания REF (контроллер внутри основания манипулятора)
- Привод шагового двигателя
- Устройство обучения Peak

Я опубликовал в открытый доступ первые две платы и Peak. При проектировании привода шагового двигателя я ориентировался на проект [unlir/XDrive](https://github.com/unlir/XDrive), разработанный моим другом. Это драйвер с замкнутым контуром на базе STM32, доступный в открытой и закрытой версиях. Закрытая версия использует высокопроизводительные дискретные MOSFET и имеет полную функциональность, в то время как открытая версия использует АЦП и чип управления по схеме отсечки, предоставляя базовые функции без поддержки CAN-протокола.

Я переработал схему печатной платы привода (добавлены файлы для двигателей на 20, 42 и 57 шагов для возможных расширений) и добавил аппаратную поддержку шины CAN. Также я полностью переписал оригинальный код, **предоставив предварительно скомпилированные бинарные файлы, которые можно прошивать напрямую**.

![](5.Docs/1.Images/fw2.png)

**Основные улучшения следующие:**

1. Код был переписан с использованием C++11, что добавило множество современных возможностей языка. Нижний уровень по-прежнему использует C, что сохраняет высокую производительность кода.
2. Аппаратная зависимость полностью разделена, что упрощает портирование на другие платформы микроконтроллеров в будущем. Убран избыточный код, структура стала более организованной.
3. Добавлены пользовательские шаблоны для протоколов CAN и UART.
4. Добавлено хранение параметров с использованием аналоговой EEPROM, что позволяет сохранять данные при отключении питания.
5. Любое положение может быть установлено как нулевая точка отсчета, что обеспечивает калибровку в пределах полуворота в обоих направлениях (а не только в одном).
6. Полная совместимость с библиотекой STM32-HAL, что позволяет использовать STM32CubeMX для генерации конфигурационного кода.
7. Другие улучшения. Для дальнейшей разработки сосредоточьтесь на файлах в папке "UserApp".

Использование драйвера **Ctrl-Step** довольно простое. После загрузки прошивки при первом включении двигатель выполнит калибровку энкодера. Если она успешна, при последующих включениях нажатие кнопки 1 переведет систему в режим замкнутого контура, и двигатель можно будет управлять, отправляя команды через CAN или UART. Инструкции можно найти в исходном коде в папке "UserApp", особенно в файлах "interface_can.cpp" и "interface_uart.cpp".

![](5.Docs/1.Images/fw3.png)

### Другие функции кнопок:

- **Одновременное нажатие обеих кнопок при включении** запускает автоматическую калибровку энкодера. Если первоначальная калибровка не удалась, её можно повторить таким образом.
- **Кратковременное нажатие кнопки 1** переключает между режимами **включения/отключения замкнутого контура**.
- **Длительное нажатие кнопки 1** перезагружает плату.
- **Кратковременное нажатие кнопки 2** очищает защиту от блокировки двигателя.
- **Длительное нажатие кнопки 2** сбрасывает целевую позицию в ноль (например, если в режиме позиционирования, положение будет сброшено в ноль).

Другие функции можно настроить через код или протоколы связи, такие как установка **нулевой точки**, **параметры PID**, идентификатор узла CAN и различные параметры движения.

### Альтернативное использование драйверов GRBL:

Можно модифицировать и использовать драйверы GRBL для управления этим манипулятором. Однако у GRBL есть недостаток в виде сильной связанности (он предназначен для ЧПУ, а не для роботизированных манипуляторов), а также неэффективный метод подключения (каждое сочленение требует отдельных проводов для «step/dir», что приводит к длинным проводам для последних суставов).

### Преимущество драйвера замкнутого контура:

В отличие от GRBL, использование интегрированного драйвера с замкнутым контуром позволяет соединить все двигатели последовательно через шину CAN, что требует всего четыре провода для подключения (два для питания и два для сигнала CAN). Модель с шиной также позволяет двигателям работать в режимах усилия, скорости, положения и траектории, в то время как импульсный режим поддерживает только положения и траектории, что ограничивает сложное управление.

### Прошивка Peak:

Программное и аппаратное обеспечение для Peak уже опубликовано в открытом доступе. Более подробную информацию можно найти в файле README в папке SubModules.

## О ядре прошивки

Основной функционал прошивки этого манипулятора заключается в расчете кинематической позы. **Я всё еще его упорядочиваю, но позже он будет открыт с лучшей упаковкой**. Прошивка была перенесена с LiteOS на более знакомый FreeRTOS, что упрощает дальнейшую разработку.

### Инструкции по использованию прошивки REF:

Прошивка включает несколько основных модулей:

- **Драйверы BSP**: Управление встроенными аппаратными компонентами, такими как OLED, IMU, светодиоды, динамики, энергонезависимая память и т.д.
- **Сторонние библиотеки**: Включают графическую библиотеку U8G2 и библиотеку сериализации Fibre.
- **Core**: Официальная библиотека HAL от ST.
- **Driver**: Драйвер ARM CMSIS.
- **Middleware**: Пакет поддержки FreeRTOS.
- **Robot**: Основная библиотека для робота, включая различные алгоритмы и драйверы.
- **UserApp**: Верхнеуровневые приложения, позволяющие разрабатывать другие программы на основе предоставленных API.

> OLED-дисплей перенесён из библиотеки Arduino U8G2, что упрощает отображение отладочной информации. Из-за ошибки аппаратного I2C в STM32 использован программный драйвер I2C для экрана, который в тестах показал более высокую частоту кадров по сравнению с аппаратным I2C.

Класс `DummyRobot` определяет всю функциональность манипулятора. Во время инициализации необходимо задать **информацию о драйвере шагового двигателя** и **параметры DH**.
![](5.Docs/1.Images/fw1.jpg)

Информация о драйвере включает в себя идентификатор узла CAN, **направление (реверс или нет)**, передаточное число редуктора и **диапазон ограничения движения**.

Значение параметров DH следующее:

- **d (offset)**: Расстояние вдоль оси предыдущего звена.
- **θ (theta)**: Угол вращения вокруг оси текущего звена.
- **r (radius)**: Расстояние от оси текущего звена до следующего.
- **α (alpha)**: Угол между осями двух последовательных звеньев.

Эти параметры используются для описания геометрии и кинематики манипулятора, что позволяет правильно рассчитывать его движение и позы.

![](5.Docs/1.Images/fw2.jpg)

Конфигурация роботизированного манипулятора должна соответствовать критерию Пайпера (три соседние оси суставов робота должны пересекаться в одной точке или быть параллельными), чтобы получить аналитические решения. Поэтому вы можете изменить структуру манипулятора на основе Dummy и заменить параметры DH, чтобы адаптировать мой код к вашему собственному дизайну манипулятора.

> **О запоминании положения и калибровке нуля при включении:**
>
> Поскольку положение абсолютного энкодера действительно только в пределах одного оборота, в промышленных манипуляторах обычно используются энкодеры на выходе для получения абсолютного положения. Однако это снижает точность в 30 раз (из-за передаточного числа редуктора). Более разумным подходом является использование "двойных энкодеров" или "энкодера с низким энергопотреблением + батареи". В этом проекте использование двойных энкодеров повлияло бы на компактность конструкции, поэтому я принял более хитрое решение: используя контур управления током двигателя, манипулятор выполняет низкокрутящийся возврат в нулевую точку после включения. При встрече с механическим ограничителем подтверждается грубая нулевая точка (без использования концевых выключателей), а затем точная корректировка нуля выполняется на основе положения однооборотного абсолютного энкодера. Этот метод обеспечивает нулевую точку без погрешностей и практически не зависит от точности изготовления, поскольку находится в пределах диапазона абсолютного энкодера в 12 градусов (360/30).

### **Прошивка Peak:**

Проект Peak основан на проекте X-Track. Более подробную информацию можно найти в репозитории Peak.

## **О настольном приложении:**

Программное моделирование, показанное в видео, основано на RoboDK. Я разработал драйвер для подключения к Dummy (документация представлена в официальных документах; оригинальная версия использовала интерфейс TCP, но я изменил её на использование последовательного интерфейса, совместимого с протоколом Dummy). Однако, поскольку RoboDK является коммерческим программным обеспечением, я также разработал собственное настольное приложение с использованием Unity3D, которое уже выпущено в репозитории.

Пока нет планов открывать исходный код настольного приложения, так как оно требует еще многих доработок. Моя цель — создать универсальное программное обеспечение, подобное RoboDK, которое можно будет использовать для самодельных роботизированных манипуляторов в будущем. Конечно, это программное обеспечение будет бесплатным.

## **Об алгоритмах управления:**

Кинематика уже реализована. Вычисления прямой и обратной кинематики основаны на традиционных параметрах DH. Прямая кинематика (углы сочленений к позе захвата) довольно проста и имеет уникальное решение. Однако обратная кинематика (поза захвата к углам сочленений) может иметь несколько решений (в общем случае 8). В моей реализации я выбираю набор углов сочленений с наименьшим максимальным изменением среди 6 углов между предыдущей и целевой позами в качестве решения. Это гарантирует, что манипулятор всегда будет переходить с минимальными угловыми перемещениями.

Далее — преобразование углов сочленений в сигналы привода двигателя. Я использую трапецеидальные кривые ускорения/замедления для планирования скорости и положения. Например, в команде MoveJ при получении команды движения по углу сочленения контроллер рассчитывает разности углов для 6 суставов, выбирает сустав с наибольшим угловым отклонением (обозначенный как θ) и вычисляет время, необходимое для движения θ, исходя из параметра JointSpeed (с учетом ускорения и замедления). Это время используется для расчета ускорения, замедления и максимальной скорости для оставшихся 5 двигателей. Затем все 6 двигателей синхронно перемещаются по рассчитанным параметрам, обеспечивая синхронизацию и плавное движение.

Шесть двигателей подключены через шину CAN. Каждый двигатель получает два идентификационных номера (свой собственный ID и ID 0) для связи (ID 0 используется для вещания и синхронизации). После получения команды движения двигатель сохраняет информацию в теневые регистры и начинает движение при получении сигнала синхронизации, что обеспечивает синхронность двигателей.

Наконец, динамическая часть еще разрабатывается и не полностью реализована. Я настоятельно рекомендую обращаться к книге "Введение в робототехнику" для упомянутых выше кинематических и динамических алгоритмов. Она предоставляет детальные объяснения.

## **Режимы команд:**

Прошивка Dummy поддерживает три различных режима команд (команды могут поступать через USB, последовательный интерфейс или CAN). Каждый режим имеет свои характеристики, как показано в таблице ниже:

|                  | Instruction Frequency | Instruction Execution     | Can Be Interrupted | Pause Between Instructions | Suitable Applications                                      |
| ---------------- | --------------------- | ------------------------- | ------------------ | ------------------------ | ---------------------------------------------------------- |
| SEQ (Sequential) | Random, Low (<5Hz)    | Executed in FIFO sequence | No                 | Yes                      | Sending a series of key poses, waiting for sequential execution, ensures key point reachability; however, there may be pauses between key points due to deceleration. Suitable for applications such as **visual picking, stacking, etc.** |
| INT (Instant)    | Random, No Limit      | Instruction Overwrites    | Yes                | No                       | Used for real-time control, where new instructions overwrite the ongoing one for immediate response. However, if a series of instructions is sent at once, only the last one will be executed. Suitable for applications such as **motion synchronization**. |
| `ToDo` TRJ (Trajectory Tracking) | Fixed, High (200Hz) | Automatic interpolation, executed at fixed intervals | No | No | Suitable for precise trajectory tracking applications; speed is reduced. Example applications include **3D printing, carving, painting, etc.** |

---

> **Особая благодарность авторам следующих проектов:**
>
> * [unlir/XDrive: шаговый двигатель с многофункциональным интерфейсом и замкнутым контуром управления.](https://github.com/unlir/XDrive)
> * [odriverobotics/ODrive: Высокопроизводительное управление двигателями](https://github.com/odriverobotics/ODrive)
> * [olikraus/u8g2: Библиотека U8glib для монохромных дисплеев, версия 2](https://github.com/olikraus/u8g2)
> * [samuelsadok/fibre: Слой абстракции для создания распределенных систем, которые работают «просто так»](https://github.com/samuelsadok/fibre)